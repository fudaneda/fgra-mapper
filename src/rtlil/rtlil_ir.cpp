#include "rtlil/rtlil_ir.h"
#include "ir/dfg_ir.h"

// split a string and convert to integer array
/*std::vector<int> strSplit2Int(const std::string &str, char split){
    std::vector<int> res;
    std::string new_str = str + split;
    size_t pos = new_str.find(split);
    while(pos != new_str.npos){        
        int value = std::stoi(new_str.substr(0, pos));
        res.push_back(value);
        new_str = new_str.substr(pos+1, new_str.size());
        pos = new_str.find(split);
    }
    return res;
}

// split a string and convert to uint64_t array
std::vector<uint64_t> strSplit2Uint64(const std::string &str, char split){
    std::vector<uint64_t> res;
    std::string new_str = str + split;
    size_t pos = new_str.find(split);
    while(pos != new_str.npos){        
        int value = std::stoull(new_str.substr(0, pos));
        res.push_back(value);
        new_str = new_str.substr(pos+1, new_str.size());
        pos = new_str.find(split);
    }
    return res;
}*/


/*=======================Cell_IR============================*/

void Cell_IR::setInportWidth(int index, int width){
    _inPortWidth[index] = width;
}

int Cell_IR::getInportWidth(int index){
    if(_inPortWidth.count(index)){
        return _inPortWidth[index];
    }else{
        return -1;
    }
}

void Cell_IR::setOutportWidth(int index, int width){
    _outPortWidth[index] = width;
}

int Cell_IR::getOutportWidth(int index){
    if(_outPortWidth.count(index)){
        return _outPortWidth[index];
    }else{
        return -1;
    }
}

std::string Cell_IR::inputWire(int index){
    if(_inWire.count(index)){
        return _inWire[index];
    }else{
        return " ";
    }

}

std::string Cell_IR::outputWire(int index){
    if(_outWire.count(index)){
        return _outWire[index];
    }else{
        return " ";
    }
}

void Cell_IR::addInputWire(int index, std::string wireName){
    _inWire[index] = wireName;
}

void Cell_IR::addOutputWire(int index, std::string wireName){
    _outWire[index] = wireName;
}

void Cell_IR::delInputWire(int index){
    if(_inWire.count(index)){
        _inWire.erase(index);
    }
}

void Cell_IR::delOutputWire(int index){
    if(_outWire.count(index)){
        _outWire.erase(index);
    }
}

// does the node is io node?
bool Cell_IR::isIOCell(){
    if(_operation == "INPUT" || _operation == "OUTPUT" || _operation == "LOAD" || _operation == "STORE" || _operation == "CLOAD" || _operation == "CSTORE"|| _operation == "CINPUT" || _operation == "COUTPUT" 
        || _operation == "TLOAD" || _operation == "TSTORE" || _operation == "TCLOAD" || _operation == "TCSTORE"){
        return true;    
    }else{
        return false;
    }
}


/*=======================Wire_IR============================*/
void Wire_IR::setSrc(std::string cellName, int index){
    _src = std::make_pair(cellName, index);
}

void Wire_IR::setDst(std::string cellName, int index){
    _dst[cellName].insert(index);
}


void Wire_IR::delDst(std::string cellName){
    if(_dst.count(cellName)){
        _dst.erase(cellName);
    }

}

void Wire_IR::delDst(std::string cellName, int index){
    if(_dst.count(cellName)){
        _dst[cellName].erase(index);
    }
}



/*=======================RTLIL_IR============================*/

//parse the RTLIL file generated by Yosys
//Viz: whether generate the dot fire for the DFG
RTLIL_IR::RTLIL_IR(std::string fileName, bool Viz){

    parseRtlil(fileName);
    _dfg = Rtlil2DFG();
    if(Viz){
        drawDFG(fileName);
    }

}

RTLIL_IR::~RTLIL_IR()
{
    if(_dfg){
        delete _dfg;
    }
}

void RTLIL_IR::addCellIR(Cell_IR* cell_ir){
    std::string name = cell_ir->name();
    _cells[name] = cell_ir;
}

void RTLIL_IR::addWireIR(Wire_IR* wire_ir){
    std::string name = wire_ir->name();
    _wires[name] = wire_ir;
}

void RTLIL_IR::delCellIR(std::string name){

}

void RTLIL_IR::delWireIR(std::string name){

}

Cell_IR* RTLIL_IR::getCellIR(std::string name){
    if(_cells.count(name)){
        return _cells[name];
    }else{
        return nullptr;
    }
}

Wire_IR* RTLIL_IR::getWireIR(std::string name){
    if(_wires.count(name)){
        return _wires[name];
    }else{
        return nullptr;
    }
}


std::string RTLIL_IR::getDfgNodeName(int id){
    std::string name;
    if(id != _dfg->id()){
        name = _dfg->node(id)->name();
    }/*else if(isDfgInput){
        name = _dfg->inputName(idx);
    }else{
        name = _dfg->outputName(idx);
    }*/
    return name;
}

void RTLIL_IR::parseRtlil(std::string fileName){ // parse the RTLIL file generated by Yosys
    std::string rtlilPath = fileName + "/mapped_rtlil.il";
    std::cout << "Parse Yosys mapped RTLIL file: " << rtlilPath << std::endl;
    std::ifstream ifs(rtlilPath);
    if(!ifs){
        std::cout << "Cannot open RTLIL file: " << fileName << std::endl;
        exit(1);
    }
    std::string line;
    bool newCell = true;
    std::map<std::string, std::set<std::string>> InportWithLoop;
    std::string cellName;
    std::map<std::string, int> lineStart = {
        {"cell", 1},
        {"wire", 2},
        {"parameter", 3},
        {"connect", 4},
        {"end", 5},
    };
    while (getline(ifs, line)){
        line.erase(0, line.find_first_not_of(" "));
        std::string spLine;
        std::istringstream in(line);
        std::vector<std::string> pline;
        while(getline(in, spLine, ' ')){
            pline.push_back(spLine);
        }
        if(pline.empty()) // empty line
            continue;
        /*for(auto elem : pline){
            std::cout << elem << std::endl;
        }
        std::cout << std::endl;*/
        int caseValue = lineStart[pline[0]];  
        switch (caseValue)
        {
        case 1:{// current line start with "cell"
            newCell = true; // start with cell means a new cell
            std::string opName = pline[1].substr(1, pline[1].length() - 1);
            std::transform(opName.begin(), opName.end(), opName.begin(), toupper);
            cellName = pline[2];
            Cell_IR* cell = new Cell_IR();
            cell->setName(cellName);
            cell->setOperation(opName);
            addCellIR(cell);
            break;
        }
        case 2:{ // current line start with "wire"
            if(pline[1] == "input" || pline[1] == "output" || (pline.size() > 2 && (pline[3] == "input" ||pline[3] == "output")))// do not record input/output wires
                break;
            /*for(auto elem : pline){
                std::cout << elem << std::endl;
            }
            std::cout << std::endl;*/
            int width;
            std::string wireName;
            Wire_IR* wire = new Wire_IR();
            if(pline[1] == "width"){
                width = std::atoi(pline[2].c_str());
                wireName = pline[3];
            }else{
                width = 1;
                wireName = pline[1];
            }
            wire->setName(wireName);
            wire->setWidth(width);
            addWireIR(wire);
            break;
        }    
        case 3:{ // current line start with "parameter"
            Cell_IR* cell = getCellIR(cellName);
            std::string parName = pline[1].substr(1, pline[1].length() - 1);
            //std::cout << parName << std::endl;
            if(cell->operation() == "LUT"){// lut should be processed specially
                if(parName == "LUT"){// $lut's parameter "\LUT" 
                    std::string LUT = pline[2];
                    int index = LUT.find("'");
                    cell->setLUT(LUT.substr(index + 1, LUT.length()));
                }else{// $lut's another parameteportr "\WIDTH", which means the size of the LUT
                    int width = std::atoi(pline[2].c_str());
                    cell->setLUTsize(width);
                    // we initial the port width of lut here
                    for(int i = 0; i < width; i++){// the width of each LUT's inport is 1
                        cell->setInportWidth(i, 1);
                    }
                    cell->setOutportWidth(0, 1); // the width of each LUT's outport is 1
                }
                //cell->setBitWidth(1);
            }else if(cell->operation() == "CONST"){ // const cell has 2 parameters: the const value; the outport width
                if(parName == "VALUE"){
                    int pos = pline[2].find_first_of('\'');
                    std::string value_s = pline[2];
                    int64_t value = 0;
                    if(pos != -1){
                        value_s = pline[2].substr(pos + 1, pline[2].length() - 1);
                        value = std::stoll(value_s, 0, 2);
                    }else{
                        value = std::atoll(value_s.c_str());

                    }
                    //std::cout << "value_s: " << value_s << std::endl;
                    cell->setValue(value);
                }else{// default has one outport
                    int width = std::atoi(pline[2].c_str());
                    cell->setOutportWidth(0, width);
                }
            }else{// other cell's parameters
                if(parName.length() > 5 && parName.substr(2, 6) == "WIDTH"){
                    char index = parName.at(0);
                    int width = std::atoi(pline[2].c_str());
                    //std::cout << "index: " << index << std::endl;
                    if(int(index) >= 65 && int(index) < 89){ // inport parameter
                        if(cell->operation() == "INPUT"){ // input cell don't set input port
                            /*if(width > cell->bitWidth()){  // the max inport width equals to the width of the cell 
                                cell->setBitWidth(width);
                            }*/
                            break;
                        }    
                        cell->setInportWidth(int(index) - 65, width);
                        /*if(width > cell->bitWidth()){  // the max inport width equals to the width of the cell 
                            cell->setBitWidth(width);
                        }*/
                    }else{// outport parameter
                        if(cell->operation() == "OUTPUT" || cell->operation() == "COUTPUT"){ // output cell don't set output port
                            /*if(width > cell->bitWidth()){  // the max inport width equals to the width of the cell 
                                cell->setBitWidth(width);
                            }*/
                            break;
                        }    
                        cell->setOutportWidth(int(index) - 89, width);
                        /*if(width > cell->bitWidth()){  // the max width equals to the width of the cell 
                            cell->setBitWidth(width);
                        }*/
                    }
                }else{
                    // std::cout << "parName: "<<parName<<" pre parameter: " <<  pline[2] << std::endl;
                    // std::cout << "paramater: " << pline[2] << std::endl;
                    if(parName == "backedge"){
                        for(int Idx = 2; Idx < pline.size(); Idx++){
                            // std::cout << pline[Idx] << std::endl;
                            pline[Idx].erase(std::remove(pline[Idx].begin(), pline[Idx].end(), '\"'), pline[Idx].end());
                            InportWithLoop[cellName].insert(pline[Idx]);// @yuan: record all the input-port has backedge 
                            // std::cout << pline[Idx] << std::endl;
                        }
                        // std::cout << std::endl;
                        // std::cout << "parName: "<<parName<<" pre parameter: " <<  pline[2] <<" pline size: " << pline.size()<< std::endl;
                        // InportWithLoop[cellName].insert(pline[2]);
                    }else if(parName == "Dependent"){
                        for(int Idx = 2; Idx < pline.size(); Idx++){
                            // std::cout << pline[Idx] << std::endl;
                            pline[Idx].erase(std::remove(pline[Idx].begin(), pline[Idx].end(), '\"'), pline[Idx].end());
                            cell->addDependency(pline[Idx]); 
                            // std::cout << pline[Idx] << std::endl;
                        }
                        // std::cout << std::endl;
                    }else{
                        pline[2].erase(std::remove(pline[2].begin(), pline[2].end(), '\"'), pline[2].end());
                        cell->setParameters(parName, pline[2]);
                    }
                }
            }
            break;
        }
        case 4:{ // current line start with "connect"
            Cell_IR* cell = getCellIR(cellName);
            char portName = pline[1].at(1);
            int portASCII = int(portName);
            if(cell->operation() == "LUT"){//lut should  be processed specially
                if(portASCII < 89){// inport
                    int LUTsize = cell->LUTsize();// the size of lut equals to the num of input
                    int BracketIdx = LUTsize == 1? 0 : 1;
                    //for(int i = LUTsize - 1; i >= 0; i--){
                    for(int i = 0; i < LUTsize; i++){
                        std::string wireName = pline[2 + BracketIdx + i];
                        // std::cout << "LUT Name: " << cell->name() <<" wire_name: " <<wireName<< " port: " << LUTsize - 1 - i << std::endl;
                        cell->addInputWire(LUTsize - 1 - i, wireName);
                        // set lut's inport as the dstination of wire
                        Wire_IR* wire = getWireIR(wireName);
                        if(!wire){
                            std::cout << "Error! The input port of LUT connects to an unknown wire!" << std::endl;
                            exit(1);
                        }else{
                            wire->setDst(cellName, LUTsize - 1 - i);
                        }
                    }
                }else{// outport
                    std::string wireName = pline[2];
                    int portIndex = portASCII - 89;
                    cell->addOutputWire(portIndex, wireName);
                    // set lut's outport as the source of wire
                    Wire_IR* wire = getWireIR(wireName);
                    if(!wire){
                        std::cout << "Error! The output port of LUT connects to an unknown wire!" << std::endl;
                        exit(1);
                    }else{
                        wire->setSrc(cellName, portIndex);
                    }
                }
            }else if(cell->operation() == "INPUT" || cell->operation() == "CONST"){// input and const cell don't set the input wire
                char portName = pline[1].at(1);
                int portASCII = int(portName);
                if(portASCII >= 89){// only set output port connections, port_name > Y
                    int portIndex = portASCII - 89;
                    std::string wireName = pline[2];
                    cell->addOutputWire(portIndex, wireName);
                    Wire_IR* wire = getWireIR(wireName);
                    if(!wire){
                        std::cout << "Error! The output port of INPUT/CONST cell connects to an unknown wire!" << std::endl;
                        exit(1);
                    }else{
                        int portWidth = cell->getOutportWidth(portIndex); 
                        if(portWidth != wire->Width()){
                            std::cout << "Error! The output port of INPUT/CONST cell connects to an unmatch width wire!" << std::endl;
                            exit(1);
                        }
                        wire->setSrc(cellName, portIndex);
                    }
                }
            }else if(cell->operation() == "OUTPUT" || cell->operation() == "COUTPUT"){// output cell don't set the output wire
                char portName = pline[1].at(1);
                int portASCII = int(portName);
                if(portASCII < 89){// only set input port connections, port_name < Y
                    int portIndex = portASCII - 65;
                    std::string wireName = pline[2];
                    cell->addInputWire(portIndex, wireName);
                    Wire_IR* wire = getWireIR(wireName);
                    if(!wire){
                        std::cout << "Error! The input port of OUTPUT cell connects to an unknown wire!" << std::endl;
                        exit(1);
                    }else{
                        int portWidth = cell->getInportWidth(portIndex); 
                        if(portWidth != wire->Width()){
                            std::cout << "Error! The input port of OUTPUT cell connects to an unmatch width wire!" << std::endl;
                            exit(1);
                        }
                        wire->setDst(cellName, portIndex);
                    }
                }
            }else{// other cells both contain input and output wires
                char portName = pline[1].at(1);
                int portASCII = int(portName);
                std::string wireName = pline[2];
                Wire_IR* wire = getWireIR(wireName);
                if(!wire){
                    std::cout << "Error! The port of functional cell connects to an unknown wire!" << std::endl;
                    exit(1);
                }
                if(portASCII < 89){// set input wires
                    int portIndex = portASCII - 65;
                    int portWidth = cell->getInportWidth(portIndex); 
                    cell->addInputWire(portIndex, wireName);
                    if(portWidth != wire->Width()){
                        std::cout << "Error! The input port of functional cell connects to an unmatch width wire!" << std::endl;
                        exit(1);
                    }
                    wire->setDst(cellName, portIndex);
                }else{// set output wires
                    int portIndex = portASCII - 89;
                    int portWidth = cell->getOutportWidth(portIndex); 
                    cell->addOutputWire(portIndex, wireName);
                    if(portWidth != wire->Width()){
                        std::cout << "Error! The output port of functional cell connects to an unmatch width wire!" << std::endl;
                        exit(1);
                    }
                    wire->setSrc(cellName, portIndex);
                }
            }
            break;
        }    
        case 5:{ // current line start with "end"
            if(newCell == true){
                newCell = false;
                cellName = " ";
            }
            break;
        }    
        default:
            break;
        }

    }
    // set the edge which is the backedge
    for(auto& cells : InportWithLoop){
        Cell_IR* cell = getCellIR(cells.first);
        for(auto& port : cells.second){
            std::string sport;
            std::istringstream backedge(port);
            std::vector<std::string> backedge_para;
            while(getline(backedge, sport, ',')){
                backedge_para.push_back(sport);
            }
            // for(auto & t: backedge_para){
            //     std::cout << t << " ";
            // }
            // std::cout << std::endl;
            // std::cout << "cell name: " << cells.first << " port: " << port<< " port.at(0): " << port.at(0) <<" port size: " << port.size()<<std::endl;
            int portIndex = int(backedge_para[0].at(0)) - 65;
            auto inWireName = cell->inputWire(portIndex);
            // _backedge[inWireName].emplace(cells.first);
            int iterDist = std::atoi(backedge_para[1].c_str()) ;
            // _iterDist[inWireName] = std::atoi(iterDist.c_str());
            _backedge[inWireName][cells.first].push_back(iterDist);
            int logicLat = std::atoi(backedge_para[2].c_str()) ;
            _backedge[inWireName][cells.first].push_back(logicLat);
            int edgeType = std::atoi(backedge_para[3].c_str()) ;
            _backedge[inWireName][cells.first].push_back(edgeType);
            // std::cout << "inWireName: " << inWireName << " portIndex: " << portIndex <<" iter_dist: "<<iterDist << " logicLat: " << logicLat << std::endl;
        }
    }

}

DFG* RTLIL_IR::Rtlil2DFG(){// transform RTLIL to DFG, similar with DFG_IR
    std::cout << "Transform RTLIL to DFG ~~" << std::endl;
    DFG* dfg = new DFG();
    dfg->setId(0); // DFG id = 0, node id = 1,...,n
    std::map <std::string, int> _inputindex;
    std::map <std::string, int> _outputindex;
    std::map <std::string, int> _nodeindex;
    for(auto cell : cellsIR()){
        //std::cout << "id: " << id << std::endl;
        if(cell.second->operation() == "CONST"){
            continue;
        }/*else if(cell.second->operation() == "INPUT"){
            int idx = _inputindex.size();
            std::string nodeName = cell.second->name();
            _inputindex[nodeName] = idx;
            dfg->setInputName(idx, nodeName);
        }else if(cell.second->operation() == "OUTPUT"){
            int idx = _outputindex.size();
            std::string nodeName = cell.second->name();
            _outputindex[nodeName] = idx;
            dfg->setOutputName(idx, nodeName);
        }*/else{// parse DFG nodes 
            int id = dfg->nodes().size() + 1;
            std::string nodeName = cell.second->name();
            std::string nodeOp = cell.second->operation();
            //int bitWidth = cell.second->bitWidth();
            // std::cout << "nodeName: " << nodeName << std::endl;
            DFGNode* dfg_node;
            if(nodeOp == "INPUT" || nodeOp == "OUTPUT" || nodeOp == "LOAD" || nodeOp == "STORE" || nodeOp == "CLOAD" || nodeOp == "CSTORE"|| nodeOp == "CINPUT" || nodeOp == "COUTPUT"
            || nodeOp == "TLOAD" || nodeOp == "TSTORE" || nodeOp == "TCLOAD" || nodeOp == "TCSTORE"){
                dfg->addIONode(id);
                DFGIONode* dfg_io_node = new DFGIONode();
                bool hasOffset = false;
                dfg_io_node->setMultiport(false);
                for(auto& par : cell.second->Parameters()){
                    // std::cout << "para name: " << par.first << " value: " << par.second << std::endl;
                    if(par.first == "ref_name"){
                        dfg_io_node->setMemRefName(par.second);
                    }else if(par.first == "size"){
                        int size = std::stoi(par.second);
                        // std::cout << "mem size: " << size << std::endl;
                        dfg_io_node->setMemSize(size);
                    }else if(par.first == "offset" ){
                        std::vector<int> values = strSplit2Int(par.second, ',');
                        dfg_io_node->setMemOffset(values[0]);
                        if(values.size() > 1){
                            dfg_io_node->setReducedMemOffset(values[1]);
                        }else{
                            dfg_io_node->setReducedMemOffset(0);
                        }
                        hasOffset = true;
                    }else if(par.first == "pattern"){
                        std::vector<int> values = strSplit2Int(par.second, ',');
                        for(int i = 0; i < values.size(); i += 2){
                            // std::cout << "patetrn 1: " << values[i] << " second: " << values[i+1] << std::endl;
                            dfg_io_node->addPatternLevel(values[i], values[i+1]);
                        }
                    }else if(par.first == "cycles"){
                        int cycles = std::stoi(par.second);
                        dfg_io_node->addPatternLevel(0, cycles);
                    }else if(par.first == "multiport"){
                        int Multiport = std::stoi(par.second);
                        if(Multiport){
                            dfg_io_node->setMultiport(true);
                        }
                        dfg_io_node->setMultiportType(Multiport);
                    }else if(par.first == "N"){//@yuan: for temporal test
                        int N = std::stoi(par.second);
                        dfg_io_node->setNumMultiportBank(N);
                    }else if(par.first == "B"){
                        int B = std::stoi(par.second);
                        dfg_io_node->setMultiportBankSize(B);
                    }else if(par.first == "branch"){
                        int branch = std::stoi(par.second);
                        // std::cout << "brabch: " << branch << std::endl;
                        dfg_io_node->setBranch(branch);
                    }else if(par.first == "controlstep"){
                        int step = std::stoi(par.second);
                        // std::cout << "brabch: " << branch << std::endl;
                        dfg_io_node->setControlStep(step);
                    }
                }
                if(!hasOffset){
                    dfg_io_node->setMemOffset(0);
                    dfg_io_node->setReducedMemOffset(0);
                }
                dfg_node = dfg_io_node;
            }else{
                dfg_node = new DFGNode();
                for(auto& par : cell.second->Parameters()){
                    if(par.first == "acc_params"){
                        // std::cout << "acc_params: " << par.second << std::endl;
                        std::vector<uint64_t> values = strSplit2Uint64(par.second, ',');
                        assert(values.size() >= 3);
                        dfg_node->setInitVal(values[0]);
                        dfg_node->setCycles((int)values[1]);
                        dfg_node->setInterval((int)values[2]);
                        dfg_node->setRepeats((int)values[3]);
                    }else if(par.first == "acc_first"){
                        int first = std::stoi(par.second);
                        if(first){
                            dfg_node->setIsAccFirst(true);
                        }else{
                            dfg_node->setIsAccFirst(false);
                        }
                    }else if(par.first == "second_initVal"){
                        uint64_t initVal = std::stoi(par.second);
                        dfg_node->set2ndInit(initVal);
                        dfg_node->setInitIdx(1); // @yuan: for the second initial value, its operand idx is fixed to 1
                    }else if (par.first == "isel_params"){
                        // std::cout << "isel_params: " << par.second << std::endl;
                        std::vector<uint64_t> values = strSplit2Uint64(par.second, ',');
                        assert(values.size() >= 3);
                        dfg_node->setCycles((int)values[0]);
                        dfg_node->setInterval((int)values[1]);
                        dfg_node->setRepeats((int)values[2]);
                    }
                }

            }
            //DFGNode* dfg_node = new DFGNode();
            dfg_node->setId(id);
            dfg_node->setName(nodeName);
            dfg_node->setOperation(nodeOp);
            //dfg_node->addBitWidth(bitWidth);
            dfg->addNode(dfg_node);
            if(nodeOp == "LUT"){
                int LUTsize = cell.second->LUTsize();
                std::string LUTconfig = cell.second->LUT();
                dfg_node->setLUTsize(LUTsize);
                dfg_node->setLUTconfig(LUTconfig);
                dfg->addLUTNode(id);
            }
            _nodeindex[nodeName] = id;
        }  
    }
    // parse the edges, according to the input wires of the cell
    bool hasCGWidth = false;
    for(auto node : _nodeindex){
        Cell_IR* cell = getCellIR(node.first);
        int nodeId = node.second;
        DFGNode* currentnode = dfg->node(nodeId);
        if(cell->isIOCell()){
            auto dcell = cell->dependencyCells();
            if(!dcell.empty()){
                DFGIONode* currentIONode = dynamic_cast<DFGIONode*>(currentnode);
                for(std::string c : dcell ){
                    std::string nodeName = "$" + c;
                    if(_nodeindex.find(nodeName) != _nodeindex.end()){
                        int srcId = _nodeindex[nodeName];
                        currentIONode->addDependency(srcId);
                        // int edgeId = dfg->edges().size();
                        // int inputSize = currentIONode->inputs().size();
                        // DFGEdge* edge = new DFGEdge(edgeId);
                        // edge->setEdge(1, srcId, 0, nodeId, inputSize);
                        // edge->setType(EDGE_TYPE_MEM);
                        // dfg->addEdge(edge);
                    }
                    // std::cout << "c: " << c << " id: " << _nodeindex[nodeName]<< std::endl;
                }
            }
        }
        //std::cout << node.first << " : " << node.second << std::endl;
        for(auto inwire : cell->inputWires()){
            int edgeId = dfg->edges().size();
            DFGEdge* edge = new DFGEdge(edgeId);
            int portIndex = inwire.first;
            Wire_IR* wire = getWireIR(inwire.second);
            std::string srcName = wire->getSrc().first; // one wire only connect to one outport
            // std::cout << "rtlil_ir 461 srcname: " << srcName << " portidx: " << portIndex << std::endl;
            int srcPort = wire->getSrc().second;
            int bitWidth = wire->Width();
            currentnode->addBitWidth(bitWidth);
            Cell_IR* srcCell = getCellIR(srcName);
            if(srcCell->operation() == "CONST"){// don't record the edge from const node
                currentnode->setImm(bitWidth ,std::make_pair(portIndex,srcCell->Value()));
                // std::cout << "rtlil_ir 570 srcname: " << srcName << " portidx: " << portIndex <<" bitWidth:" <<bitWidth<<std::endl;
            }/*else if(srcCell->operation() == "INPUT"){// connec to input node
                edge->setEdge(0, _inputindex[srcName], nodeId, portIndex);
                edge->setWidth(width);
                dfg->setInputWidth(_inputindex[srcName], width);
                dfg->addEdge(edge);
            }*/else{
                if(bitWidth > 1 && !hasCGWidth){
                    dfg->setCGWidth(bitWidth);
                    hasCGWidth = true;
                }
                int srcId = _nodeindex[srcName];
                edge->setEdge(bitWidth, srcId, srcPort, nodeId, portIndex);
                if(_backedge.count(inwire.second)){
                    if(_backedge[inwire.second].count(node.first)){ // @yuan: should find the corresponding cell
                        int iterDist = _backedge[inwire.second][node.first][0];
                        edge->setBackEdge(true);
                        edge->setIterDist(iterDist);
                        int logicLat = _backedge[inwire.second][node.first][1];
                        edge->setlogicLat(logicLat);
                        int edgeType = _backedge[inwire.second][node.first][2];
                        if(edgeType == 1){
                            edge->setType(EDGE_TYPE_MEM);
                        }else if(edgeType == 2){
                            edge->setType(EDGE_TYPE_CTRL);
                        }else{
                            edge->setType(EDGE_TYPE_DATA);
                        }
                        // std::cout << "rtlil_ir627 wirename: " << wire->name() << " is loopend" << " iterDist:" <<iterDist<<std::endl;
                    }
                }
                dfg->addEdge(edge);
            }
        }
        /*for(auto outwire : cell->outputWires()){
            Wire_IR* wire = getWireIR(outwire.second);
            for(auto elem : wire->getDst()){
                std::string dstName = elem.first;
                Cell_IR* dstCell = getCellIR(dstName);
                if(dstCell->operation() == "OUTPUT"){// connect to output node
                    int width = wire->Width();
                    int edgeId = dfg->edges().size();
                    DFGEdge* edge = new DFGEdge(edgeId);
                    int portIndex = outwire.first;
                    edge->setEdge(nodeId, portIndex, 0, _outputindex[dstName]);// output node only has one inport
                    edge->setWidth(width);
                    dfg->addEdge(edge);
                    dfg->setOutputWidth(_outputindex[dstName], width);
                }else{
                    continue;
                }
            }
        }*/
    }
    std::cout << "dfg node size: " << dfg->nodes().size() << std::endl;
    std::cout << "dfg wire size: " << dfg->edges().size() << std::endl;
    return dfg;
}


void RTLIL_IR::drawDFG(std::string fileName){// draw the DFG in dot format
    std::string filename = fileName + "/yosys_mapped_dfg.dot";
    std::ofstream ofs(filename);
    DFG* dfg = _dfg;
    int dfgId = dfg->id();
    ofs << "Digraph G {\n";
    /*for(auto& elem : dfg->inputs()){
        std::string name = getDfgNodeName(dfgId, elem.first);
        name.erase(std::remove(name.begin(), name.end(), '$'), name.end());
        std::string quoteName = "\"" + name + "\"";
        int width = dfg->InputWidth(elem.first);
        ofs << quoteName << "[Width = " << width <<", opcode = input"  << "];\n";
    }
    for(auto& elem : dfg->outputs()){
        std::string name = getDfgNodeName(dfgId, elem.first, false);
        name.erase(std::remove(name.begin(), name.end(), '$'), name.end());
        std::string quoteName = "\"" + name + "\"";
        int width = dfg->OutputWidth(elem.first);
        int srcNodeId = elem.second.first;
        std::string srcName = getDfgNodeName(srcNodeId, elem.second.second);
        srcName.erase(std::remove(srcName.begin(), srcName.end(), '$'), srcName.end());
        std::string quoteSrcName = "\"" + srcName + "\"";
        ofs << quoteName << "[Width = " << width <<", opcode = output"  << "];\n";
        ofs << quoteSrcName << "->" << quoteName ;
        ofs << "[Width = " << width << ", operand = 0" << "];\n";
    }*/
    for(auto& elem : dfg->nodes()){
        auto node = elem.second;
        //int nodeWidth = 32;
        auto name = getDfgNodeName(node->id());
        name.erase(std::remove(name.begin(), name.end(), '$'), name.end());
        std::string nodeOp = node->operation();
        std::string quoteName = "\"" + name + "\"";
        //std::cout << "Node name: " << name << std::endl;
        if(node->operation() == "LUT"){
            //nodeWidth = 1;
            int LUTsize = node->LUTsize();
            std::string LUTconfig = node->LUTconfig();
            LUTconfig.erase(std::remove(LUTconfig.begin(), LUTconfig.end(), '\''), LUTconfig.end());
            ofs << quoteName << "[" <<"opcode = " << nodeOp  << ", LUT_size = " << LUTsize <<", LUT_config = " << LUTconfig<< "];\n";
        }else if(dfg->isIONode(elem.first)){
            std::string nodeName = getDfgNodeName(node->id());
            Cell_IR* cell = getCellIR(nodeName);
            if(cell != nullptr){
                ofs << quoteName << "[" <<"opcode = " << nodeOp ;
                for(auto& par : cell->Parameters()){
                    ofs << ", "<<par.first << "=" << "\"" << par.second << "\""; 
                }
                ofs <<"];\n";
            }else{
                ofs << quoteName << "[" <<"opcode = " << nodeOp  << "];\n";
            }
            DFGIONode* ioNode = dynamic_cast<DFGIONode*>(node);
            if(!ioNode->dependencyNodes().empty()){
                for(auto c : ioNode->dependencyNodes()){
                    std::string srcName = getDfgNodeName(c);
                    srcName.erase(std::remove(srcName.begin(), srcName.end(), '$'), srcName.end());
                    std::string quoteSrcName = "\"" + srcName + "\"";
                    ofs << quoteSrcName << "->" << quoteName ;
                    ofs << "[style = dashed, color = blue];\n";
                }
            }
        }
        else{
            ofs << quoteName << "[" <<"opcode = " << nodeOp  << "];\n";
        }
        for(auto& inedge : node->inputEdges()){
            int width = inedge.first;
            for(auto& edges: inedge.second){
                int portIndex = edges.first;
                DFGEdge* edge = dfg->edge(edges.second);
                if(edge->isMemEdge()) continue;
                int srcNodeId = edge->srcId();
                bool isBackEdge = edge->isBackEdge();
                //int srcIndex = edge->srcPortIdx();
                std::string srcName = getDfgNodeName(srcNodeId);
                srcName.erase(std::remove(srcName.begin(), srcName.end(), '$'), srcName.end());
                std::string quoteSrcName = "\"" + srcName + "\"";
                ofs << quoteSrcName << "->" << quoteName ;
                ofs << "[Width = " << width << ", operand = " << portIndex; 
                if(isBackEdge){
                    int iterDist = edge->iterDist();
                    ofs << ", backedge = 1, style = dashed, iterdist = " << iterDist<<"];\n";
                }else{
                    ofs<< "];\n";
                }
            }
        }
        for (auto& elem : node->bitWidths()){
                //std::cout << "bit width: "<< elem << std::endl;
            /*if(node->operation() == "lut"){
                std::cout << "bit width: "<< elem << std::endl;
            }*/
            if(node->hasImm(elem)){
                std::string constname = "const_" + std::to_string(node->id());
                std::string conName = "\"" + constname + "\"";
                int value = node->imm(elem).second;
                ofs << conName << "[" <<"opcode = CONST, value = " << value << "];\n";
                int constPort  = node->immIdx(elem);
                ofs << conName << "->" << quoteName ;
                ofs << "[" << "operand = " << constPort << "];\n";
            }   
        }
    }
    ofs << "}\n";

}